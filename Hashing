Hashing in Java is a technique for mapping data to a secret key, that can be used as a unique identifier for data. 
It employs a function that generates those keys from the data; this function is known as the Hash-function, 
and the output of this function (keys) is known as Hash-values. 
To provide quick access to the data, we store it as key(Hash values) value(real data) pairs in an array called Hash-table, 
which uses keys as indexes and values as the data to be stored at each index location.

//frequency counter to check frequency without HashMap 
Time Complexity : This method iterates over the full array of size 'N' for each of the 'Q' queries , so the time complexity will be O(N*Q) .
import java.util.*;
public class Main
{
	public static void main(String[] args) {
		 int[] a = {1, 3, 3, 4, 1, 4, 4, 4, 4}; //given Array
		 int n = a.length;  //calculate size of Array
		 
		 Scanner sc = new Scanner (System.in);
		 int q = sc.nextInt();
		 
		 for (int i = 0 ; i < q ; i++ ) {
		     int qry = sc.nextInt();
		     int frq = 0;
		     
		     for (int j = 0 ;j < n ; j++) {
		         if (a[j] == qry) frq++;
		     }
		     
		     System.out.println(qry + " number occurs " + frq + " times in the array");
		 } 
	}
}


data ---------> Hash Function ------------ > HashValue (Key) 
Key(HashValue) is unique identifier of the data .
(key,data)  pair is stored in array called HashTable as key as indexes and values as the data to be stored at that index.
Hashing is basically as data structure that stores data effitiently to solve problems.
https://www.scaler.com/topics/java/what-is-hashing-in-java/

//simple array hash table to query from array a with time complexity O(1);
//Time Complexity : As we are running a single for loop , O(N) time is required , to answer all the queries , we iterate over the queries and answer each one of them in O(1) time as we have all the answers pre calculated :-) 
//So , total time taken : O(N+Q).

//Space Complexity : We created an extra array of size 'N' , which is array 'b' . So space taken is O(N) by the algorithm.

import java.util.*;
public class Main
{
	public static void main(String[] args) {
		 int[] a = {1, 3, 3, 4, 1, 4, 4, 4, 4}; //given Array
		 int n = a.length;  //calculate size of Array
         int[] b = new int[n + 1]; //create a new array (frequency counter) of size n+1
         //create hashtable for loopkup with timecomplexity O(1)
         for (int i = 0; i < n ; i++) {  //array frequency counter for lookup
             int x = a[i];
             b[x]++;
         } 
		 
		 int[] queries = {1,4}; //numbers whose frequency needs to be calculated
		 int qn = queries.length;
		 for (int i = 0 ; i < qn ; i++) {
		     int x = queries[i];
		     System.out.println(x + " number occurs " + b[x] + " times in the array");
		 } 
	}
}

HashSet stores unique elements without any associated values, while HashMap stores key-value pairs where the keys are unique identifiers and the values are associated data.
HashSet is a collection that stores unique elements, meaning it does not allow duplicate values. It is implemented using a hash table, which means the elements are stored in a hash table using their hash code as the key. This makes it very efficient to add, remove, and search for elements.
In a HashSet, the elements are not stored in any particular order. This means that when you iterate over the elements, the order in which you receive them is not guaranteed. HashSet does not provide any methods to retrieve the elements in a specific order.

HashMap is a data structure that stores key-value pairs in a hash table. It allows you to access the values based on the keys, and it guarantees constant time complexity for most operations. This means that HashMap is particularly useful when you need to quickly retrieve data based on a specific key. In a HashMap, the keys are unique, but the values may be duplicated. This means that you can have multiple keys with the same value.
Like HashSet, HashMap does not provide any methods to retrieve the elements in a specific order.
Another difference between the two data structures is the way they handle collisions. In a hash table, collisions occur when two different keys hash to the same index in the table. In HashMap, collisions are resolved by using linked lists to store multiple values at the same index. In HashSet, collisions are resolved by simply inserting the element into the next available slot in the table.

[C++]unordered_set<int> b : On an average , each operation like insert , find and delete takes O(1) time on average . Worst Case can take O(N) time for each operation but it rarely occurs.

[C++]set<int> b : On an average , each operation like insert , find and delete takes O(logN) time on average . Worst Case will also take O(logN) time for each operation . Thats the advantage over unordered_set<int>b. All elements are stored in sorted order.

In Java, properties of HashSet is very similar to that of unordered_set in C++. It implements set interface which ensures no duplicate elements are present in hashset. The insertion of an object in hashset is based on its hash value, therefore when you iterate over hashset the order of elements that you'll get will most probably be different than how they were entered in the hashset. Hash value is the unique value of an object generated by a hash function to uniquely identify an object.

[Java]HashSet<Integer> set : Average time complexity for add, remove and look-up operation of HashSet is O(1). Worst case time complexity is O(N) which rarely occurs.

[Java]TreeSet<Integer> set : On an average , each operation like insert , find and delete takes O(logN) time on average . Worst Case will also take O(logN) time for each operation. Thats the advantage over HashSet<Integer> set. All elements are stored in sorted order.


In C++, unordered_map<int,int> b : On an average , each operation like insert , find and delete takes O(1) time on average . Worst Case can take O(N) time for each operation but it rarely occurs. 

map<int,int> b : On an average , each operation like insert , find and delete takes O(logN) time on average . Worst Case will also take O(logN) time for each operation . Thats the advantage over unordered_map<int,int> b. All keys maintain sorted order.

In Java, HashMap<Integer, String> map : Average time complexity is O(1) and worst case time complexity is O(n). Similar to unordered_map in C++.

https://docs.google.com/document/d/1e_JQXvnEwq5Gp_JGHpny7f6EVb5lecjncIydU7twPao/edit
https://docs.google.com/document/d/1zadjci7AJqGgPFkn0d_FV9LIX6blVJKZCfneYM6F2mc/edit


HashSet example : check if arr2 is subset of arr1
import java.util.*;

public class Main{
    
    public static void main (String[] args) {
        int[] arr1 = {6,7,3,2};
        int[] arr2 = {2,3};
        int n1 = arr1.length; //calculate size of arr1
        int n2 = arr2.length; //calculate size of arr2
        //create Hashset for lookup from arr1
        Set<Integer> st = new HashSet<>();
        for (int i = 0 ; i < n1 ; i++) {
            st.add(arr1[i]);
        } 
        for (int i = 0;i < n2 ; i++) { //lookup hashset and if any element not present  then return as not subset
            if(!st.contains(arr2[i])) {
                System.out.println("arr2 is not subset of arr1");
                return;
            }
        }
        System.out.println("arr2 is subset of arr1"); // if all elements present in Hashset then print is subset
    }
}


HashMap example : frequency counter for large array


import java.util.*;
public class Main
{
	public static void main(String[] args) {
        int[] a = {1,3,3,4,1,4,4,4,4}; // array
        int n = a.length;
        Map <Integer,Integer> hmap = new HashMap<>();
        for (int i = 0 ; i < n ; i++) {  //HashMap freq counter O(N)
            int x = a[i];
            int count = hmap.getOrDefault(x,0);
            hmap.put(x,count+1);
        } 
        int[] queries = {4,1};
        int nq = queries.length;
        for (int i = 0 ; i < nq ; i++ ) {
            int x = queries[i];
            int output = hmap.getOrDefault(x,0); //O(1);
            System.out.print((output + " "));
        }
        //Below for loop took O(q) time.
        //Hence total time : O(n+q).
	}
}

